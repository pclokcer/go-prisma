// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package relations

import (
	"context"
	"os"
	"testing"

	"github.com/prisma/prisma-client-go/engine"
	"github.com/prisma/prisma-client-go/engine/mock"
	"github.com/prisma/prisma-client-go/runtime/builder"
	"github.com/prisma/prisma-client-go/runtime/lifecycle"
	"github.com/prisma/prisma-client-go/runtime/raw"
	"github.com/prisma/prisma-client-go/runtime/transaction"
	"github.com/prisma/prisma-client-go/runtime/types"

	// no-op import for go modules
	_ "github.com/iancoleman/strcase"
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"
	_ "github.com/takuoki/gocase"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type usersActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var usersOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "surname"},
	{Name: "phone"},
}

type UsersRelationWith interface {
	getQuery() builder.Query
	with()
	usersRelation()
}

type UsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
}

type usersDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersDefaultParam) field() builder.Field {
	return p.data
}

func (p usersDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p usersDefaultParam) usersModel() {}

type UsersOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
}

type usersOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersOrderByParam) field() builder.Field {
	return p.data
}

func (p usersOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p usersOrderByParam) usersModel() {}

type UsersCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	isCursor()
}

type usersCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersCursorParam) field() builder.Field {
	return p.data
}

func (p usersCursorParam) isCursor() {}

func (p usersCursorParam) getQuery() builder.Query {
	return p.query
}

func (p usersCursorParam) usersModel() {}

type UsersParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	usersModel()
}

type usersParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p usersParamUnique) usersModel() {}

func (usersParamUnique) unique() {}

func (p usersParamUnique) field() builder.Field {
	return p.data
}

func (p usersParamUnique) getQuery() builder.Query {
	return p.query
}

type UsersEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
}

type usersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersEqualsParam) usersModel() {}

func (usersEqualsParam) equals() {}

func (p usersEqualsParam) field() builder.Field {
	return p.data
}

func (p usersEqualsParam) getQuery() builder.Query {
	return p.query
}

type UsersEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	usersModel()
}

type usersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersEqualsUniqueParam) usersModel() {}

func (usersEqualsUniqueParam) unique() {}
func (usersEqualsUniqueParam) equals() {}

func (p usersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UsersSetParam interface {
	field() builder.Field
	settable()
	usersModel()
}

type usersSetParam struct {
	data builder.Field
}

func (usersSetParam) settable() {}

func (p usersSetParam) field() builder.Field {
	return p.data
}

func (p usersSetParam) usersModel() {}

type UsersWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	idField()
}

type UsersWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	idField()
}

type usersWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIDSetParam) usersModel() {}

func (p usersWithPrismaIDSetParam) idField() {}

type UsersWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	idField()
}

type usersWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIDEqualsParam) usersModel() {}

func (p usersWithPrismaIDEqualsParam) idField() {}

func (usersWithPrismaIDSetParam) settable()  {}
func (usersWithPrismaIDEqualsParam) equals() {}

type usersWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIDEqualsUniqueParam) usersModel() {}
func (p usersWithPrismaIDEqualsUniqueParam) idField()    {}

func (usersWithPrismaIDEqualsUniqueParam) unique() {}
func (usersWithPrismaIDEqualsUniqueParam) equals() {}

type UsersWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	nameField()
}

type UsersWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	nameField()
}

type usersWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaNameSetParam) usersModel() {}

func (p usersWithPrismaNameSetParam) nameField() {}

type UsersWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	nameField()
}

type usersWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaNameEqualsParam) usersModel() {}

func (p usersWithPrismaNameEqualsParam) nameField() {}

func (usersWithPrismaNameSetParam) settable()  {}
func (usersWithPrismaNameEqualsParam) equals() {}

type usersWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaNameEqualsUniqueParam) usersModel() {}
func (p usersWithPrismaNameEqualsUniqueParam) nameField()  {}

func (usersWithPrismaNameEqualsUniqueParam) unique() {}
func (usersWithPrismaNameEqualsUniqueParam) equals() {}

type UsersWithPrismaSurnameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	surnameField()
}

type UsersWithPrismaSurnameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	surnameField()
}

type usersWithPrismaSurnameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaSurnameSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaSurnameSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaSurnameSetParam) usersModel() {}

func (p usersWithPrismaSurnameSetParam) surnameField() {}

type UsersWithPrismaSurnameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	surnameField()
}

type usersWithPrismaSurnameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaSurnameEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaSurnameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaSurnameEqualsParam) usersModel() {}

func (p usersWithPrismaSurnameEqualsParam) surnameField() {}

func (usersWithPrismaSurnameSetParam) settable()  {}
func (usersWithPrismaSurnameEqualsParam) equals() {}

type usersWithPrismaSurnameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaSurnameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaSurnameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaSurnameEqualsUniqueParam) usersModel()   {}
func (p usersWithPrismaSurnameEqualsUniqueParam) surnameField() {}

func (usersWithPrismaSurnameEqualsUniqueParam) unique() {}
func (usersWithPrismaSurnameEqualsUniqueParam) equals() {}

type UsersWithPrismaPhoneEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	phoneField()
}

type UsersWithPrismaPhoneSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	phoneField()
}

type usersWithPrismaPhoneSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPhoneSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPhoneSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPhoneSetParam) usersModel() {}

func (p usersWithPrismaPhoneSetParam) phoneField() {}

type UsersWithPrismaPhoneWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	phoneField()
}

type usersWithPrismaPhoneEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPhoneEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPhoneEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPhoneEqualsParam) usersModel() {}

func (p usersWithPrismaPhoneEqualsParam) phoneField() {}

func (usersWithPrismaPhoneSetParam) settable()  {}
func (usersWithPrismaPhoneEqualsParam) equals() {}

type usersWithPrismaPhoneEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPhoneEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPhoneEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPhoneEqualsUniqueParam) usersModel() {}
func (p usersWithPrismaPhoneEqualsUniqueParam) phoneField() {}

func (usersWithPrismaPhoneEqualsUniqueParam) unique() {}
func (usersWithPrismaPhoneEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single users.
func (r usersActions) CreateOne(
	_name UsersWithPrismaNameSetParam,
	_surname UsersWithPrismaSurnameSetParam,
	_phone UsersWithPrismaPhoneSetParam,

	optional ...UsersSetParam,
) usersCreateOne {
	var v usersCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "users"
	v.query.Outputs = usersOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _surname.field())
	fields = append(fields, _phone.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r usersCreateOne) With(params ...UsersRelationWith) usersCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type usersCreateOne struct {
	query builder.Query
}

func (p usersCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p usersCreateOne) usersModel() {}

func (r usersCreateOne) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersCreateOne) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type usersFindUnique struct {
	query builder.Query
}

func (r usersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindUnique) with()          {}
func (r usersFindUnique) usersModel()    {}
func (r usersFindUnique) usersRelation() {}

func (r usersActions) FindUnique(
	params UsersEqualsUniqueWhereParam,
) usersFindUnique {
	var v usersFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "users"
	v.query.Outputs = usersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usersFindUnique) With(params ...UsersRelationWith) usersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindUnique) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindUnique) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindUnique) Update(params ...UsersSetParam) usersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "users"

	var v usersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersUpdateUnique struct {
	query builder.Query
}

func (r usersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpdateUnique) usersModel() {}

func (r usersUpdateUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpdateUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersFindUnique) Delete() usersDeleteUnique {
	var v usersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "users"

	return v
}

type usersDeleteUnique struct {
	query builder.Query
}

func (r usersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usersDeleteUnique) usersModel() {}

func (r usersDeleteUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersDeleteUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersFindFirst struct {
	query builder.Query
}

func (r usersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindFirst) with()          {}
func (r usersFindFirst) usersModel()    {}
func (r usersFindFirst) usersRelation() {}

func (r usersActions) FindFirst(
	params ...UsersWhereParam,
) usersFindFirst {
	var v usersFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "users"
	v.query.Outputs = usersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersFindFirst) With(params ...UsersRelationWith) usersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindFirst) OrderBy(params ...UsersOrderByParam) usersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersFindFirst) Skip(count int) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersFindFirst) Take(count int) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersFindFirst) Cursor(cursor UsersCursorParam) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersFindFirst) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindFirst) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usersFindMany struct {
	query builder.Query
}

func (r usersFindMany) getQuery() builder.Query {
	return r.query
}

func (r usersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindMany) with()          {}
func (r usersFindMany) usersModel()    {}
func (r usersFindMany) usersRelation() {}

func (r usersActions) FindMany(
	params ...UsersWhereParam,
) usersFindMany {
	var v usersFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "users"
	v.query.Outputs = usersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersFindMany) With(params ...UsersRelationWith) usersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindMany) OrderBy(params ...UsersOrderByParam) usersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersFindMany) Skip(count int) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersFindMany) Take(count int) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersFindMany) Cursor(cursor UsersCursorParam) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersFindMany) Exec(ctx context.Context) (
	[]UsersModel,
	error,
) {
	var v []UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersFindMany) ExecInner(ctx context.Context) (
	[]InnerUsers,
	error,
) {
	var v []InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersFindMany) Update(params ...UsersSetParam) usersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "users"

	r.query.Outputs = countOutput

	var v usersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersUpdateMany struct {
	query builder.Query
}

func (r usersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpdateMany) usersModel() {}

func (r usersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpdateMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersFindMany) Delete() usersDeleteMany {
	var v usersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "users"

	v.query.Outputs = countOutput

	return v
}

type usersDeleteMany struct {
	query builder.Query
}

func (r usersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usersDeleteMany) usersModel() {}

func (r usersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersDeleteMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func NewusersUniqueTxResult() usersUniqueTxResult {
	return usersUniqueTxResult{
		result: &transaction.Result{},
	}
}

type usersUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p usersUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p usersUniqueTxResult) IsTx() {}

func (r usersUniqueTxResult) Result() (v *UsersModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewusersManyTxResult() usersManyTxResult {
	return usersManyTxResult{
		result: &transaction.Result{},
	}
}

type usersManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p usersManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p usersManyTxResult) IsTx() {}

func (r usersManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type usersUpsertOne struct {
	query builder.Query
}

func (r usersUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r usersUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpsertOne) with()          {}
func (r usersUpsertOne) usersModel()    {}
func (r usersUpsertOne) usersRelation() {}

func (r usersActions) UpsertOne(
	params UsersEqualsUniqueWhereParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "users"
	v.query.Outputs = usersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usersUpsertOne) Create(

	_name UsersWithPrismaNameSetParam,
	_surname UsersWithPrismaSurnameSetParam,
	_phone UsersWithPrismaPhoneSetParam,

	optional ...UsersSetParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _surname.field())
	fields = append(fields, _phone.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r usersUpsertOne) Update(
	params ...UsersSetParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r usersUpsertOne) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpsertOne) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template client.gotpl ---
const schema = `generator client {
    provider          = "go run github.com/prisma/prisma-client-go"
    disableGoBinaries = true
    output            = "./generatedPrisma"
    package           = "relations"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model users {
    id      Int    @id @unique @default(autoincrement())
    name    String @db.VarChar
    surname String @db.VarChar
    phone   String @db.VarChar
}
`
const schemaConnectionURL = ""
const schemaEnvVarName = "DATABASE_URL"

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = false

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//   client := db.NewClient()
//   if err := client.Prisma.Connect(); err != nil {
//     handle(err)
//   }
//
//   defer func() {
//     if err := client.Prisma.Disconnect(); err != nil {
//       panic(fmt.Errorf("could not disconnect: %w", err))
//     }
//   }()
func NewClient() *PrismaClient {
	c := newClient()

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.Users = usersActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// Users provides access to CRUD methods.
	Users usersActions
}

// --- template enums.gotpl ---

type UsersScalarFieldEnum string

const (
	UsersScalarFieldEnumID      UsersScalarFieldEnum = "id"
	UsersScalarFieldEnumName    UsersScalarFieldEnum = "name"
	UsersScalarFieldEnumSurname UsersScalarFieldEnum = "surname"
	UsersScalarFieldEnumPhone   UsersScalarFieldEnum = "phone"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.Users = usersMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	Users usersMock
}

type usersMock struct {
	mock *Mock
}

type UsersMockExpectParam interface {
	ExtractQuery() builder.Query
	usersModel()
}

func (m *usersMock) Expect(query UsersMockExpectParam) *usersMockExec {
	return &usersMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type usersMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *usersMockExec) Returns(v UsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usersMockExec) ReturnsMany(v []UsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usersMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UsersModel represents the `json:"users"` model and is a wrapper for accessing fields and methods
type UsersModel struct {
	InnerUsers
	RelationsUsers
}

// InnerUsers holds the actual data
type InnerUsers struct {
	ID      int    `json:"id"`
	Name    string `json:"name"`
	Surname string `json:"surname"`
	Phone   string `json:"phone"`
}

// RelationsUsers holds the relation data separately
type RelationsUsers struct {
}

// --- template query.gotpl ---

// Users acts as a namespaces to access query methods for the Users model
var Users = usersQuery{}

// usersQuery exposes query functions for the users model
type usersQuery struct {

	// ID
	//
	// @required
	// @unique
	ID usersQueryIDInt

	// Name
	//
	// @required
	Name usersQueryNameString

	// Surname
	//
	// @required
	Surname usersQuerySurnameString

	// Phone
	//
	// @required
	Phone usersQueryPhoneString
}

func (usersQuery) Not(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usersQuery) Or(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usersQuery) And(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type usersQueryIDInt struct{}

// Set the required value of ID
func (r usersQueryIDInt) Set(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r usersQueryIDInt) SetIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r usersQueryIDInt) Increment(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name: "increment",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) IncrementIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r usersQueryIDInt) Decrement(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name: "decrement",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) DecrementIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r usersQueryIDInt) Multiply(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name: "multiply",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) MultiplyIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r usersQueryIDInt) Divide(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name: "divide",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) DivideIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}
	return r.Divide(*value)
}

func (r usersQueryIDInt) Equals(value int) usersWithPrismaIDEqualsUniqueParam {

	return usersWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) EqualsIfPresent(value *int) usersWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return usersWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryIDInt) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r usersQueryIDInt) Cursor(cursor int) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r usersQueryIDInt) In(value []int) usersParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryIDInt) InIfPresent(value []int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.In(value)
}

func (r usersQueryIDInt) NotIn(value []int) usersParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryIDInt) NotInIfPresent(value []int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.NotIn(value)
}

func (r usersQueryIDInt) Lt(value int) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) LtIfPresent(value *int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lt(*value)
}

func (r usersQueryIDInt) Lte(value int) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) LteIfPresent(value *int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lte(*value)
}

func (r usersQueryIDInt) Gt(value int) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) GtIfPresent(value *int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gt(*value)
}

func (r usersQueryIDInt) Gte(value int) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) GteIfPresent(value *int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gte(*value)
}

func (r usersQueryIDInt) Not(value int) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDInt) NotIfPresent(value *int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r usersQueryIDInt) LT(value int) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r usersQueryIDInt) LTIfPresent(value *int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r usersQueryIDInt) LTE(value int) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r usersQueryIDInt) LTEIfPresent(value *int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r usersQueryIDInt) GT(value int) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r usersQueryIDInt) GTIfPresent(value *int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r usersQueryIDInt) GTE(value int) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r usersQueryIDInt) GTEIfPresent(value *int) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.GTE(*value)
}

// base struct
type usersQueryNameString struct{}

// Set the required value of Name
func (r usersQueryNameString) Set(value string) usersWithPrismaNameSetParam {

	return usersWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r usersQueryNameString) SetIfPresent(value *string) usersWithPrismaNameSetParam {
	if value == nil {
		return usersWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryNameString) Equals(value string) usersWithPrismaNameEqualsParam {

	return usersWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) EqualsIfPresent(value *string) usersWithPrismaNameEqualsParam {
	if value == nil {
		return usersWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryNameString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r usersQueryNameString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r usersQueryNameString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryNameString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryNameString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryNameString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryNameString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryNameString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryNameString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryNameString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryNameString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryNameString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryNameString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryNameString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryNameString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryNameString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryNameString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryNameString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryNameString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQuerySurnameString struct{}

// Set the required value of Surname
func (r usersQuerySurnameString) Set(value string) usersWithPrismaSurnameSetParam {

	return usersWithPrismaSurnameSetParam{
		data: builder.Field{
			Name:  "surname",
			Value: value,
		},
	}

}

// Set the optional value of Surname dynamically
func (r usersQuerySurnameString) SetIfPresent(value *string) usersWithPrismaSurnameSetParam {
	if value == nil {
		return usersWithPrismaSurnameSetParam{}
	}

	return r.Set(*value)
}

func (r usersQuerySurnameString) Equals(value string) usersWithPrismaSurnameEqualsParam {

	return usersWithPrismaSurnameEqualsParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) EqualsIfPresent(value *string) usersWithPrismaSurnameEqualsParam {
	if value == nil {
		return usersWithPrismaSurnameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQuerySurnameString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "surname",
			Value: direction,
		},
	}
}

func (r usersQuerySurnameString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "surname",
			Value: cursor,
		},
	}
}

func (r usersQuerySurnameString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQuerySurnameString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQuerySurnameString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQuerySurnameString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQuerySurnameString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQuerySurnameString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQuerySurnameString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQuerySurnameString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQuerySurnameString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQuerySurnameString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQuerySurnameString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySurnameString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQuerySurnameString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQuerySurnameString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQuerySurnameString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "surname",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQuerySurnameString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryPhoneString struct{}

// Set the required value of Phone
func (r usersQueryPhoneString) Set(value string) usersWithPrismaPhoneSetParam {

	return usersWithPrismaPhoneSetParam{
		data: builder.Field{
			Name:  "phone",
			Value: value,
		},
	}

}

// Set the optional value of Phone dynamically
func (r usersQueryPhoneString) SetIfPresent(value *string) usersWithPrismaPhoneSetParam {
	if value == nil {
		return usersWithPrismaPhoneSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryPhoneString) Equals(value string) usersWithPrismaPhoneEqualsParam {

	return usersWithPrismaPhoneEqualsParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) EqualsIfPresent(value *string) usersWithPrismaPhoneEqualsParam {
	if value == nil {
		return usersWithPrismaPhoneEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryPhoneString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "phone",
			Value: direction,
		},
	}
}

func (r usersQueryPhoneString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "phone",
			Value: cursor,
		},
	}
}

func (r usersQueryPhoneString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryPhoneString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryPhoneString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryPhoneString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryPhoneString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryPhoneString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryPhoneString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryPhoneString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryPhoneString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryPhoneString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryPhoneString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPhoneString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryPhoneString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryPhoneString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryPhoneString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "phone",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryPhoneString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}
